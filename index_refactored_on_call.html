<!DOCTYPE html>

<head>
  <link rel="stylesheet" href="styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Roboto:wght@300;400&display=swap"
    rel="stylesheet">

</head>

<body id="main">
  <script src="dist/bundle.js"></script>
  <script src="./src/index.js"></script>
  <div class="left" id="left">
    <div class="chess-holder" id="chessHolder"></div>
  </div>
  <div class="right">
    <div class="tree-holder" id="treeHolder"></div>
    <canvas id="canvas"></canvas>
  </div>
</body>

<script type="module">
  /*
  
  
  Main chessboard/move code
  
  
  */
  import { move, getPiece, chess } from './src/index.js'
  let fens = [];
  let board_positions = [];
  let C_BOARD_CELLS = 8;
  generateGrid();
  function generateGrid() {
    let holder = document.getElementById("chessHolder");
    let white = true;
    for (let i = 0; i < 64; i++) {
      if (i % 8 === 0) {
        white = !white;
      }
      let div = document.createElement("div");
      if (white) {
        div.classList.add("square-white");
      }
      else {
        div.classList.add("square-black");
      }
      div.id = i;
      white = !white;
      holder.appendChild(div);
    }
    for (let i = 0; i < 64; i++) {
      addPosition(i); //Save the position of each piece added
    }
    placePieces();
  }
  // Pushes position to 2D array
  function addPosition(id) {
    var rect = document.getElementById(id);
    board_positions.push([rect.offsetLeft, rect.offsetTop, id, '']);
  }
  // Visually places each piece on the board
  function placePieces() {
    let square_id = 0;
    for (let row = 0; row < C_BOARD_CELLS; row++) {
      for (let column = 0; column < C_BOARD_CELLS; column++) {
        if (chess.board()[row][column]) {
          let type = chess.board()[row][column].type;
          let color = chess.board()[row][column].color;
          let piece = '';
          if (type === 'r') {
            piece = 'rook';
          }
          else if (type === 'n') {
            piece = 'knight';
          }
          else if (type === 'b') {
            piece = 'bishop';
          }
          else if (type === 'q') {
            piece = 'queen';
          }
          else if (type === 'k') {
            piece = 'king';
          }
          else if (type === 'p') {
            piece = 'pawn';
          }
          piece = color + piece;


          board_positions[square_id][3] = piece;
          let src = './pieces/' + piece + '.png';
          let chess_piece = document.createElement("img");
          chess_piece.src = src;
          chess_piece.classList.add("piece");
          chess_piece.id = "i" + square_id;
          chess_piece.setAttribute("draggable", false);
          chess_piece.addEventListener('mousedown', function () {
            setClickedId(this.id); //get id of square clicked
          });
          chess_piece.addEventListener('mouseup', function () {
            setClickedId(''); //set clickedId to null
            findPos(this.id); //get position of square clicked
          });
          document.getElementById(square_id).appendChild(chess_piece);
        }
        square_id++;
      }
    }
  }

  let clickedId = '';
  function setClickedId(id) {
    clickedId = id;
  }
  /*
  Use the distance formula to determine the square that is closest to the piece
  */
  function findPos(board_id) {
    let x = document.getElementById(board_id).offsetLeft;
    let y = document.getElementById(board_id).offsetTop;
    let nearestDistance = 1000000;
    let newId = 0;
    for (let i = 0; i < 63; i++) {
      if (Math.sqrt(Math.pow((board_positions[i][0] - x), 2) + Math.pow((board_positions[i][1] - y), 2)) < nearestDistance) {
        nearestDistance = Math.sqrt(Math.pow((board_positions[i][0] - x), 2) + Math.pow((board_positions[i][1] - y), 2));
        newId = board_positions[i][2];
      }
    }
    movePiece(board_id, newId);
  }
  //Move a piece from one id to the new id based on positioning
  function movePiece(board_id, newId) {
    let piece = getPiece(getSquare(document.getElementById(board_id).parentNode.id));
    if (piece === 'P') {
      piece = '';
    }
    let str = piece + getSquare(newId);
    try {
      move(str);
      board_positions[newId][3] = board_positions[document.getElementById(board_id).parentNode.id][3];
      board_positions[document.getElementById(board_id).parentNode.id][3] = '';
      document.getElementById(board_id).style.position = 'relative';
      document.getElementById(board_id).style.left = "0px";
      document.getElementById(board_id).style.top = "0px";
      document.getElementById(newId).appendChild(document.getElementById(board_id));
      updateArray(str);
    }
    catch (err) {
      //if not valid move
      console.log(err);
      document.getElementById(board_id).style.position = 'relative';
      document.getElementById(board_id).style.left = "0px";
      document.getElementById(board_id).style.top = "0px";
    }
  }
  let offset = 25;
  document.addEventListener('mousemove', function (event) {
    if (clickedId !== '') {
      //box offset
      document.getElementById(clickedId).style.position = 'absolute';
      document.getElementById(clickedId).style.left = event.pageX - offset + "px";
      document.getElementById(clickedId).style.top = event.pageY - offset + "px";
    }
  });

  function replaceParent(child, newParent) {
    var oldParent = child.parentNode;
    oldParent.replaceChild(newParent, child);
    newParent.appendChild(child);
  }
  //Convert id to chess square id
  function getSquare(id) {
    const row = Math.floor(id / 8);
    const col = id % 8;
    const file = String.fromCharCode('a'.charCodeAt(0) + col);
    const rank = 8 - row;
    return `${file}${rank}`;
  }
  /*
  
  
  The tree code
  
  
  */
  /*
  This moves array is the basis of the tree
  A first line created such as e4 e5 f4 f5 will be stored in the first row of the array
    with the ids 0, 1, 2, 3 respectively.
  If a new branch is created at move e5, such as e4 e5 g4 g5, the second row of the array
    will be updated to have ids 0, 1, 4, 5 respectively.
  This allows us to save multiple lines of chess using move names and ids, same ids show sprouting from the same branch.
  indexes: 0: move name, 1: id, 2: x, 3: y, 4: row, 5: column
  */
  let moves = [[['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0], ['', -1, 0, 0, 0, 0]]]; //initializes the array to have maximum ten moves in a line
  let currId = 0; //current piece id in moves array
  let currRow = 0; //current row in moves array
  let currColumn = 0; //current column in moves array
  let maxRow = 0;

  /*
  Once a move is made you must determine whether it creates a new branch, continues a line, or is repeated or not
  Then, based on these possibilities, update the moves array
  */
  function updateArray(move) {
    let newBranch = false;
    let repeated = false;
    let index = 0;
    for (let r = 0; r < moves.length; r++) {
      for (const square of moves[r]) {
        if (square[4] === currRow) {
          index = r; //calculate your current row as in order of branches (not the same necessarily as the row in the array)
        }
      }
    }
    if (moves[index][currColumn + 1]) {
      if (move !== moves[index][currColumn + 1][0]) {
        if (moves[index][currColumn + 1][0] !== '') {
          newBranch = true;
          maxRow++;
        }
      }
      else {
        currColumn++;
        repeated = true;
      }
    }
    if (!newBranch) {
      if (!repeated) {
        if (moves.length === 1) {
          fens.push(chess.fen()); //save fen
          moves[index][currColumn] = [move, currId, 0, 0, currRow, currColumn]; //update moves column
          currId++;
          currColumn++;
        }
        else {
          fens.push(chess.fen());
          moves[index][currColumn + 1][0] = move;
          moves[index][currColumn + 1][1] = currId;

          currId++;
          currColumn++;
        }
      }
      else {
        currColumn++;
      }
    }
    else {
      if (!repeated) {
        fens.push(chess.fen());
        moves.splice(index + 1, 0, []); //If new branch created new row in moves array
        currColumn++;
        let prev = index + 1;
        //Here we are pushing a new row to the moves array which copies the original branch + the new move
        for (let i = 0; i < currColumn; i++) {
          let x = [];
          for (let z = 0; z < moves[index][i].length; z++) {
            x[z] = moves[index][i][z];
          }
          moves[index + 1].push(x);
          moves[index + 1][i][4] = maxRow;
          console.log(currRow);
        }
        currRow = maxRow;
        moves[prev].push([move, currId, 0, 0, maxRow, currColumn]);
        for (let i = currColumn + 1; i < moves[0].length; i++) {
          moves[prev].push(['', -1, 0, 0, maxRow, i]);
        }
        currId++;
      }
    }
    console.log(moves);
    prepareTree();
  }
  //This function converts the data from being a simple list of the move array to a tree
  function prepareTree() {
    //This initially lays out the array like a grid
    let yoffset = window.innerHeight * .8 / 2 + 15;
    let offset = moves.length * -40;
    for (let row = 0; row < moves.length; row++) {
      for (let column = 0; column < moves[row].length; column++) {
        let x = column * 150;
        let y = yoffset + offset + row * 80;
        moves[row][column][2] = x;
        moves[row][column][3] = y;
      }
    }
    /*
    The most vital tree code is below
    Here we find moves that are similar and positioning them to be vertically in the middle of the first similar move and the last
    There are definitely more efficient ways to go about this, but as of now I am using this approach.
    */
    let poses = [];
    for (let row = 1; row < moves.length; row++) {
      for (let column = moves[row].length - 1; column > -1; column--) {
        if (moves[row][column][1] !== -1) {
          let divergeId = row;
          for (let nr = row; nr > -1; nr--) {
            if (moves[row][column][1] !== moves[nr][column][1]) {
              break;
            }
            divergeId--;
          }
          let pos = (moves[divergeId + 1][column][3] + moves[row][column][3]) / 2;
          poses.push([divergeId + 1, column, pos])
          for (let nr = divergeId + 2; nr < row + 1; nr++) {
            moves[nr][column][3] = (moves[divergeId + 1][column][3] + moves[row][column][3]) / 2;
            pos = (moves[divergeId + 1][column][3] + moves[row][column][3]) / 2;
          }
        }

      }
    }
    for (let i = 0; i < poses.length; i++) {
      moves[poses[i][0]][poses[i][1]][3] = poses[i][2];
    }
    clearTree();
    loadTree();
  }
  //Erase the tree each time a move is made
  function clearTree() {
    while (document.getElementById("treeHolder").firstChild) {
      document.getElementById("treeHolder").removeChild(document.getElementById("treeHolder").firstChild);
    }
  }
  //Load the tree based on the positioning
  function loadTree() {
    var c1 = document.getElementById("canvas");
    var ctx = c1.getContext("2d");
    ctx.canvas.width = window.innerWidth * .8;
    ctx.canvas.height = window.innerHeight * .8;

    for (let row = 0; row < moves.length; row++) {
      let white = true;
      for (let column = 0; column < moves[row].length; column++) {
        if (moves[row][column][0] !== '') {
          let rowId = row;
          let HighestRow = row;
          //Check if this is most recent box, if yes then append it to html
          for (let r1 = 0; r1 < moves.length; r1++) {
            if (moves[r1][column][4] > HighestRow && moves[r1][column][1] === moves[row][column][1]) {
              HighestRow = r1;

            }
          }
          if (HighestRow === row) {

            let div = document.createElement('div');
            if (!white) {
              div.classList.add('grid-test');
            }
            else {
              div.classList.add('grid-test-white');
            }
            white = !white;
            div.addEventListener('click', loadFen, false);
            div.curr = moves[row][column][1];
            div.row = moves[row][column][4];
            div.col = moves[row][column][5];
            let p = document.createElement('P');
            let t = document.createTextNode(moves[row][column][0]);
            p.appendChild(t);
            div.appendChild(p);
            div.style.left = "calc(" + moves[row][column][2] + "px)";
            div.style.top = moves[row][column][3] + "px"

            document.getElementById("treeHolder").appendChild(div);
          }
          let xoffset = 53;
          let yoffset = 15;


          if (column > 0) {
            //Draw lines connecting the boxes
            ctx.beginPath();
            ctx.moveTo(moves[row][column][2], moves[row][column][3] + yoffset);
            ctx.lineTo(moves[row][column - 1][2] + xoffset, moves[row][column][3] + yoffset);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.closePath();
            ctx.stroke();
          }
          if (column < moves[row].length - 1) {
            if (moves[row][column][3] !== moves[row][column + 1][3]) {
              ctx.beginPath();
              ctx.moveTo(moves[row][column][2] + xoffset, moves[row][column][3] + yoffset);
              ctx.lineTo(moves[row][column][2] + xoffset, moves[row][column + 1][3] + yoffset);
              ctx.strokeStyle = '#FFFFFF';
              ctx.lineWidth = 2;
              ctx.closePath();
              ctx.stroke();

            }
          }

        }

      }
    }

  }
  //Load fen when a position is clicked
  function loadFen(evt) {
    let i = evt.currentTarget.curr
    chess.load(fens[i]);
    currRow = evt.currentTarget.row;
    currColumn = evt.currentTarget.col;
    clearPieces();
    placePieces();
  }
  //Delete all pieces
  function clearPieces() {
    for (let i = 0; i < 64; i++) {
      if (document.getElementById("i" + i)) {
        document.getElementById("i" + i).remove();
      }
    }
  }
</script>